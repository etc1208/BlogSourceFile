---
title: 那些年我们一起追过的正则表达式
date: 2016-09-22 09:39:52
tags: [正则表达式]
---

转自：[前端圈](http://mp.weixin.qq.com/s?__biz=MzA5NTM2MTEzNw==&mid=2736710690&idx=1&sn=9b9471d3d7b69d8208dca0f7b3e2c70c&chksm=b6aac53c81dd4c2afa62c46e22b8218760da7cc95d56eb2281577912240c245565e3b4c68463&scene=0#rd)

最近在做笔试题的时候频繁遇到正则，总是囫囵吞枣掌握的马马虎虎，今天整理整理。

![正则表达式](http://www.admin10000.com/UploadFiles/Document/201502/09/20150209094337862701.JPG)

<!--more-->

##js与正则的关系

在js中定义一个正则有两种方法，一个是实例化，一个是字面量。分别看一下：

	var re = /\w+/;
	或者：
	var re = new RegExp('\\w+');
	//这两者等价
如果想添加一些flags也是没有问题的。比较常用的flag有。/i,/g,/ig,/m.

	/i (忽略大小写,ignore)
	/g (全文查找出现的所有匹配字符,global)
	/m (多行查找,multiLine)
	/ig(全文查找、忽略大小写,ignore+global)

## 正则预定字符
预定字符，就是用程序比较难表达的一些字符，比如回车键，tab键(通过空格来区分达到的效果)。常用的有：

	字符	效果
	\t	制表符,其实就是一个“Tab”键
	\r	回车符,如果你使用过word应该之后，在一个段落后面那个东西吧。 :)
	\n	换行符，他和\r是有故事的,等下说，我们继续
恩，大部分就是这几个了。 上面提到 \r和\n，他们到底有什么却别。 没错，看字面量，感觉return 不就是换行吗？ 其实，这样说没错，但是得区分系统，在Unix为扩展的系统，在每行的结尾只有"\n",而在window下则是:"\n\r"(顺序不能换). 所以，为了解决系统的差异，就出现了两种: \r || \n.所以一般，我们匹配换行需要使用.\r||\n一起使用。

	var reg = /[\r\n]/g;
	这样就能保证系统的兼容性。

## 字符类
所谓的字符类同样也是将你平常要花很多时间做出来的，集成为一个简洁表达。(相当于写库)。常用的字符类有如下几个。

	字符	效果
	.	匹配换行符以外的任意字符
	\d	匹配所有数字
	\D	匹配非数字
	\s	匹配一个空格符
	\S	匹配非空格
	\w	匹配字母数字下划线=>其实就是匹配单词word(简单易懂)
	\W	匹配!字母数字下划线=>就是不匹配单词
## 锚字符
这个应该算是正则里面，取名最好理解的一个。使用正则就是停船一样，你需要设置你停的位置，我也需要设置我的边界。常用的有一下几个：

	锚字符	效果
	^	匹配字符串的开头，在多行检索中，匹配一行的开头
	$	匹配字符串的结尾，在多行检索中，匹配一行的结尾
	\b	匹配一个单词的边界
	\B	匹配非单词边界
	
## 量词字符
"望文生义",这类字符使用来限定某某出现的次数的。常用的有：

	代码 / 语法	说明
	*	重复零次或更多次
	+	重复一次或更多次
	?	重复零次或一次
	{n}	重复n次
	{n,}	重复n次或更多次
	{n, m}	重复n到m次
	
上面说了这么多内置的字符，那我想使用特定字符类怎么办嘞。其实也很简单。使用\转义字符。 比如我想匹配大括号."{}".我可以这样用：

	console.log(/\{.+\}/.test("{123}"));
	//true
但事实上，量词还分为3种，有贪婪量词，惰性量词，支配性量词。
区分的依据是根据引擎的解析不同而形成。

### 贪婪量词

	这类量词指的就是上文所说的: *,+,?。

他的匹配方法就是，全文匹配，如果不成功，则，将末尾的最后一个字符减去，再匹配，如果还不成功，则，再减一次。只到为0。 接着，往中间移动一位，再进行匹配，同样的匹配模式。

	console.log(/.+/.test("abcd"));
	//true
### 惰性量词

	使用方法： 基本量词 ?

该量词和贪婪量词就像，一个是消极怠工，一个是积极工作。 惰性量词一开始只会匹配一个字符，如果不成功，则在进行匹配。

	console.log(/\d+?/.test("1fjkdf"));
	//true
这里阐述一些惰性和贪婪匹配的区别。

我们也通常把惰性称为最少重复匹配。

	举个例子:
	我们现在需要匹配blablablabla. 中的b~a间的词。
	
	使用贪婪匹配:
	var str = "blablablabla";
	console.log(str.match(/(b.*a)/g));
	//["blablablabla"]
	我们最少重复匹配(惰性匹配)
	console.log(str.match(/(b.*?a)/g)); 
	//["bla", "bla", "bla", "bla"]
## 中括号的用法
我们从小学学过来，老师告诉我们，我们使用括号有3种，一个是( ),一个是[],一个是{}。

而在正则里面，大括号已经被量词字符给强占了，只剩下[]和(). 这里我们来说一下，中括号。

[],在正则里面代表的是一个单元字符，或者我宁愿叫他"或"括号. 因为他起到的主要作用就是，你可以匹配这个或者匹配那个或者...

	var reg = /[abc]/;
	console.log(reg.test("a"));
	//true
可以看出，reg可以匹配 a|b|c. 平常使用的时候，可以直接向一个字符使用就可以了。

### 异或表达
这里会出现一个问题，比如，我不想匹配a,b,c中的任意一个该怎么办呢？ 其实，只需要在"[]"里面加上"^"即可。
	
	console.log(/[^abc]/.test("c")); 
	//false

### 范围字符
范围字符，就是可以省略一些周所周知的。 比如匹配26英文字母可以直接使用：a-z. 因为我们已经都知道了这个的意义。

其实，上面所说的字符类完全就可以使用中括号来代替。
	
	\d => [0-9]
	\w => [0-9a-zA-Z_]
	\S => [^\t\n\x0B\f\r]  (\f标识分页符)
	...

这就是中括号的常用用法。

## 小括号使用
小括号的主要作用其实就是分组。平常是用来提取匹配到的字符串。

### 分组使用
使用()对内容进行区分。
	
	console.log(/(jimmy)+/.test("jimmy")); 
	//true
而且，配合使用match方法，可以获得匹配到的内容.

	var name = "My name is Jimmy";
	console.log(name.match(/(Jimmy)/g));
	//["Jimmy"]
#### 需要注意在括号里面写正则和没有括号的时候，是没有区别的。

	var name = "My name is Jimmy Jimy";
	console.log(name.match(/(Jimm?y)/g)); 
	//["Jimmy", "Jimy"]
### 候选(或)
这个就相当于将括号加上一个或的功能. 即，在()里面使用"|"进行分隔。
	
	var name = "My name is Jimmy sam";
	var reg = /(jimmy|sam)+?/ig;
	console.log(name.match(reg));
	//["jimmy","sam"]
### 反向引用
这个的主要功能，就是给匹配到的小括号加上数字，来表明他是第几个匹配到的。如果不加，则默认从左到右的顺序为1,2,3...
	
	var reg = /(100)\1/;
	var reg2 = /(100)(99)(101)\1\2\3/; 
	//1=>100,2=>99,3=>101
	在js中，通常是和replace搭配，才有威力。
	var reg = /(100) (99)/;
	var str = "100 99";
	console.log(str.replace(reg,"$2 $1")); 
	//99 100

## 非捕获分组
我们直接使用 "(...)"进行的匹配是捕获分组。 我们来说一下什么叫捕获. 上文中我们使用match进行正则匹配，而返回的数组中的元素就是通过正则捕获的内容。 这就叫捕获。 

那这里的非捕获，是什么意思呢？ 其实很简单，就是通过match不会匹配到内容。但还是可以起到分组的效果。 

格式为: (?:xxx)
它最常用的地方就是匹配html.

	var str=`<div class="pin">
	           <div class="box">
	             <img src="img/P_001.jpg" />
	           </div>
	        </div>`;
	var reg = /<div(?:.|\r|\n)*div>/gi;
	console.log(str.match(reg));

可以看到 “/< div(?:.|\r|\n)*div>/gi” 我这里使用的是贪婪匹配。他的结果是，尽量匹配到最外层的< /div>标签。

即上面的结果为：

	<div class="pin">
	     <div class="box">
	        <img src="img/P_001.jpg" />
	     </div>
	</div>
可以看出，贪婪匹配，对于两个重复的/div 他会匹配到最外一层。
那我们使用惰性匹配试一试。

	/< div(?:.|\r|\n)*?div>/gi
	得到的结果为:
	<div class="pin">
	     <div class="box">
	        <img src="img/P_001.jpg" />
	     </div>
可以看出少了一个< /div>,原因就是，惰性匹配尽量只会匹配到第一个重复的< /div>上面的。

#### 所以，总结一下，在使用正则匹配的时候需要搞清楚到底什么时候用惰性，什么时候用贪婪，这点很重要。 贪婪会匹配最外层，惰性会匹配最里层。

