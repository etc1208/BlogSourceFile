<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Koa学习笔记 | Etc1208 Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="转载自：http://book.apebook.org/minghe/koa-action/index.html
koa.js 是下一代的node.js框架，由Express团队开发，通过生成器（generators JavaScript 1.7新引入的，用于解决回调嵌套的方案），减少异步回调，提高代码的可读性和可维护性，同时改进了错误处理.">
<meta property="og:type" content="article">
<meta property="og:title" content="Koa学习笔记">
<meta property="og:url" content="http://yoursite.com/2016/06/21/Koa学习笔记/index.html">
<meta property="og:site_name" content="Etc1208 Blog">
<meta property="og:description" content="转载自：http://book.apebook.org/minghe/koa-action/index.html
koa.js 是下一代的node.js框架，由Express团队开发，通过生成器（generators JavaScript 1.7新引入的，用于解决回调嵌套的方案），减少异步回调，提高代码的可读性和可维护性，同时改进了错误处理.">
<meta property="og:image" content="http://image.lxway.com/thumb/280x220/4/15/415ba8e9778a4d424cbf8b0bebdbebe7.png">
<meta property="og:updated_time" content="2016-06-22T02:14:51.271Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Koa学习笔记">
<meta name="twitter:description" content="转载自：http://book.apebook.org/minghe/koa-action/index.html
koa.js 是下一代的node.js框架，由Express团队开发，通过生成器（generators JavaScript 1.7新引入的，用于解决回调嵌套的方案），减少异步回调，提高代码的可读性和可维护性，同时改进了错误处理.">
<meta name="twitter:image" content="http://image.lxway.com/thumb/280x220/4/15/415ba8e9778a4d424cbf8b0bebdbebe7.png">
  
    <link rel="alternative" href="/atom.xml" title="Etc1208 Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="http://imgsrc.baidu.com/forum/w%3D580/sign=baf99437e51190ef01fb92d7fe199df7/743caa1ea8d3fd1f7ef8e6e0324e251f97ca5faa.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://imgsrc.baidu.com/forum/w%3D580/sign=baf99437e51190ef01fb92d7fe199df7/743caa1ea8d3fd1f7ef8e6e0324e251f97ca5faa.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Yang He</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
						<li>About</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
							<li><a href="/tags/前端">前端</a></li>
				        
							<li><a href="/tags/笔记">笔记</a></li>
				        
							<li><a href="/tags/读书">读书</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/etc1208" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/2707541947/profile?topnav=1&wvr=6&is_all=1" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/yang-he-93" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="/599068284@qq.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/Express/" style="font-size: 10px;">Express</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Koa/" style="font-size: 13.33px;">Koa</a> <a href="/tags/Node/" style="font-size: 13.33px;">Node</a> <a href="/tags/xtemplate/" style="font-size: 10px;">xtemplate</a> <a href="/tags/前端/" style="font-size: 20px;">前端</a> <a href="/tags/我/" style="font-size: 10px;">我</a> <a href="/tags/模板引擎/" style="font-size: 10px;">模板引擎</a> <a href="/tags/笔记/" style="font-size: 16.67px;">笔记</a> <a href="/tags/简历/" style="font-size: 10px;">简历</a> <a href="/tags/读书/" style="font-size: 10px;">读书</a> <a href="/tags/随笔/" style="font-size: 13.33px;">随笔</a> <a href="/tags/面试/" style="font-size: 10px;">面试</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">我叫杨赫，来自北京邮电大学，现在是计算机学院在读研究生。热爱前端，热爱绘画和健身，喜欢分享</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Yang He</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://imgsrc.baidu.com/forum/w%3D580/sign=baf99437e51190ef01fb92d7fe199df7/743caa1ea8d3fd1f7ef8e6e0324e251f97ca5faa.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Yang He</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
					<li><a href="/tags/前端">前端</a></li>
		        
					<li><a href="/tags/笔记">笔记</a></li>
		        
					<li><a href="/tags/读书">读书</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/etc1208" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/2707541947/profile?topnav=1&wvr=6&is_all=1" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/yang-he-93" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="/599068284@qq.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-Koa学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/21/Koa学习笔记/" class="article-date">
  	<time datetime="2016-06-21T02:36:28.000Z" itemprop="datePublished">2016-06-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Koa学习笔记
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Koa/">Koa</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node/">Node</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔记/">笔记</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>转载自：<a href="http://book.apebook.org/minghe/koa-action/index.html" target="_blank" rel="external">http://book.apebook.org/minghe/koa-action/index.html</a></p>
<p>koa.js 是下一代的node.js框架，由Express团队开发，通过生成器（generators JavaScript 1.7新引入的，用于解决回调嵌套的方案），减少异步回调，提高代码的可读性和可维护性，同时改进了错误处理.</p>
<p><img src="http://image.lxway.com/thumb/280x220/4/15/415ba8e9778a4d424cbf8b0bebdbebe7.png" alt="Koa"></p>
<a id="more"></a>
<p>koa 的先天优势在于 generator，带来的主要好处如下：</p>
<ul>
<li>更优雅、简单、安全的中间件机制，后面章节会详细说明</li>
<li>更优雅、简单的异常处理</li>
<li>更优雅、简单的异步编程方式<h1 id="安装-generator-k"><a href="#安装-generator-k" class="headerlink" title="安装 generator-k"></a>安装 generator-k</h1></li>
</ul>
<p><code>generator-k</code> 是koa项目工程生成器，带有经过筛选的优秀中间件，生成即用。</p>
<pre><code>npm install -g yo generator-k
</code></pre><p>generator-k 依赖于 yoeman，所以必须安装 yo。</p>
<p>安装成功后，创建一个 book 目录（作为demo工程），并进入，然后运行：</p>
<pre><code>yo k
</code></pre><p>运行应用</p>
<pre><code>node --harmony app.js
</code></pre><p>app.js 的核心代码是：</p>
<pre><code>var koa = require(&apos;koa&apos;);
var app = koa();
app.listen(3000);
</code></pre><h1 id="koa应用初见"><a href="#koa应用初见" class="headerlink" title="koa应用初见"></a>koa应用初见</h1><pre><code>var koa = require(&apos;koa&apos;);
var app = koa();

app.use(function *(){
    var path = this.path;
    this.body = path;
});

app.listen(3000);
</code></pre><p>初始化 koa ：</p>
<pre><code>var koa = require(&apos;koa&apos;);
var app = koa();
</code></pre><p>使用<code>app.use()</code>注入中间件，这是与 express 最大不同的地方。</p>
<p>所有的koa中间件，必须是<code>generator function</code>，即 <code>function *(){}</code> 语法，不然会报错。</p>
<p><strong>中间件 的上下文 this，指向用户当前的请求</strong>，中间件只有在请求时才会触发逻辑，比如获取当前请求的路径，可以使用：</p>
<pre><code>app.use(function *(){
    var path = this.path;
});
</code></pre><p><code>this.body</code> 用于控制输出到页面的内容，比如：</p>
<pre><code>app.use(function *(){
    this.body = &apos;&lt;p&gt;我是个html片段&lt;/p&gt;&apos;;
});
</code></pre><p>可以注入多个中间件，koa 会从上到下执行，然后从下到上执行。</p>
<pre><code>app.use(function *(){
    this.demo = &apos;test text&apos;;
});

app.use(function *(){
    this.body = this.demo;
});
</code></pre><p>其实 app.use() 就干了一件事，就是将中间件放入一个数组，真正执行逻辑的是：</p>
<pre><code>app.listen(3000);
</code></pre><p>koa 的 <code>listen()</code> 除了指定了 http 服务的端口号外，还会启动 <code>http server</code>，等价于：</p>
<pre><code>var http = require(&apos;http&apos;);
http.createServer(app.callback()).listen(3000);
</code></pre><p>后面这种繁琐的形式有什么用呢？</p>
<p>一个典型的场景是启动 https 服务，默认 app.listen(); 是启动 http 服务，启动 https 服务就需要：</p>
<pre><code>var https = require(&apos;https&apos;);
https.createServer(app.callback()).listen(3000);
</code></pre><h1 id="koa路由"><a href="#koa路由" class="headerlink" title="koa路由"></a>koa路由</h1><p>koa是个极简的web框架，简单到连路由模块都没有配备，多个页面在koa中要这么写：</p>
<pre><code>app.use(function *(){
    //我是首页
    if(this.path===&apos;/&apos;){

    }
});

app.use(function *(){
    //我是详情页
    if(this.path===&apos;/detail&apos;){

    }
});
</code></pre><p>我们需要引入个路由中间件<code>koa-router</code> ，有了 koa-router 我们就可以像写 express 路由一样，写 koa 应用页面：</p>
<p>注入 koa-router 中间件：</p>
<pre><code>var router = require(&apos;koa-router&apos;);
app.use(router(app));
</code></pre><p>简单的路由写法：</p>
<pre><code>app.get(&apos;/&apos;, function *(next) {
    //我是首页
    //this 指向请求
});
app.get(&apos;/detail/:id&apos;, function *(next) {
    //我是详情页面
    //:id 是路由通配规则，示例请求 /detail/123 就会进入该 generator function 逻辑
    var id = this.params.id; //123
});
</code></pre><p>除了最常用的<code>get()</code>外，还有<code>post()</code>、<code>put()</code> 、<code>patch()</code> 、<code>delete()</code>。</p>
<p>koa-router 拥有丰富的 api 细节，用好这些 api ，可以让页面代码更为优雅与可维护。</p>
<p>比如 <code>param()</code>方法，用于路由参数的处理：</p>
<pre><code>app.param(&apos;id&apos;,function *(id,next){
    this.id = Number(id);
    if ( typeof this.id != &apos;number&apos;) return this.status = 404;
    yield next;
}).get(&apos;/detail/:id&apos;, function *(next) {
    //我是详情页面
    var id = this.id; //123
    this.body = id;
});
</code></pre><p>param() 用于封装参数处理中间件，当访问 /detail/:id 路由时，会先执行 param() 定义的 generator function 逻辑。</p>
<p><strong>函数的第一个是路由参数的值，next 是中间件流程关键标识变量。</strong></p>
<pre><code>yield next;
</code></pre><p>表示执行下一个中间件。</p>
<p><strong>通过 param() ，我们可以把参数的处理给抽象出来。</strong></p>
<h1 id="koa的错误处理"><a href="#koa的错误处理" class="headerlink" title="koa的错误处理"></a>koa的错误处理</h1><p>koa 有 <code>error</code> 事件，当发生错误时，可以通过该事件，对错误进行统一的处理。</p>
<p>我们创建个 error.js：</p>
<pre><code>var koa = require(&apos;koa&apos;);
var app = koa();

app.on(&apos;error&apos;, function(err,ctx){
    if (process.env.NODE_ENV != &apos;test&apos;) {
        console.log(err.message);
        console.log(err);
    }
});   

app.listen(3000);
</code></pre><p>监听 error 事件：</p>
<p><code>err 参数</code>： 错误对象，留意抛异常时，请务必抛出 Error 对象，不能只是简单的字符串，这是良好的编码习惯.</p>
<p><code>ctx</code> ：为发生请求的上下文对象</p>
<p><code>process.env.NODE_ENV</code> 是环境变量配置。</p>
<p>process.env.NODE_ENV != ‘test’ 即不是单元测试环境时。</p>
<p>我们注入个中间件，并抛出个异常：</p>
<pre><code>app.use(function *(){
    throw new Error(&apos;demo error&apos;);
});
</code></pre><p>再次强调，<strong>抛出异常必须是 Error 实例</strong>。</p>
<p>运行：node –harmony error.js，打开 <a href="http://localhost:3000，页面会打印出" target="_blank" rel="external">http://localhost:3000，页面会打印出</a> “Internal Server Error” （这是koa对错误的默认处理）。</p>
<p>同时会触发 error 事件，打印出 err.message。</p>
<p>“Internal Server Error” 的页面信息过于简陋，我们<strong>引入 koa-onerror 中间件，优化错误信息</strong>。</p>
<p>koa-onerror 会在 <code>process.env.NODE_ENV === &#39;development&#39;</code>（不存在环境变量时，也会输出错误信息） 时抛出错误堆栈信息。</p>
<pre><code>var onerror = require(&apos;koa-onerror&apos;);
onerror(app);
</code></pre><p>再次运行试试，页面打印的信息就会变成：</p>
<pre><code>Error
Looks like something broke!


Error: demo error
    at Object.&lt;anonymous&gt; (/dev/node/k-demo/error.js:5:11)
    at GeneratorFunctionPrototype.next (native)
    at Object.respond (/dev/node/k-demo/node_modules/koa/lib/application.js:172:10)
    at GeneratorFunctionPrototype.next (native)
    at Object.&lt;anonymous&gt; (/dev/node/k-demo/node_modules/koa/node_modules/koa-compose/index.js:37:12)
    at GeneratorFunctionPrototype.next (native)
    at next (/dev/node/k-demo/node_modules/koa/node_modules/co/index.js:83:21)
    at Object.&lt;anonymous&gt; (/dev/node/k-demo/node_modules/koa/node_modules/co/index.js:56:5)
    at Server.&lt;anonymous&gt; (/dev/node/k-demo/node_modules/koa/lib/application.js:123:8)
    at Server.EventEmitter.emit (events.js:110:17)
</code></pre><h1 id="应用环境配置"><a href="#应用环境配置" class="headerlink" title="应用环境配置"></a>应用环境配置</h1><p>我们通常通过环境变量，来区分各个应用的部署环境，根据不同的环境使用不同的配置，比如在开发环境中，我们将错误堆栈信息直接抛到页面中，而在生产环境中，我们会跳转到一个友好的错误页面。</p>
<p><strong>启动应用时，可以带上定义的环境变量</strong>：</p>
<pre><code>NODE_ENV=development node --harmony app.js
</code></pre><p>我们配置了个 NODE_ENV 环境变量，定义为开发环境（development）。</p>
<p><strong>（PS: WIN下配置环境变量的方式不同，需要使用 set NODE_ENV=development。）</strong></p>
<p>打开 config/config.js，可以找到针对开发环境做的配置：</p>
<pre><code>var _ = require(&apos;underscore&apos;);
//本地/开发环境配置
var local = require(&apos;./local&apos;);
if(process.env.NODE_ENV === &apos;local&apos; || process.env.NODE_ENV === &apos;development&apos;){
    //使用local.js中的配置覆盖config.js中的配置
    config = _.extend(config,local);
}
</code></pre><p><strong>process.env</strong> 包含了应用所有配置的环境变量。</p>
<p>local.js 的配置内容如下：</p>
<pre><code>module.exports = {
    &quot;env&quot;:&quot;local&quot;,
    &quot;debug&quot;: true
};
</code></pre><p>为了方便中间件获取应用配置，我们将配置信息，注入到中间件上下文：</p>
<pre><code>var config = require(&apos;./config/config&apos;);
app.use(function *(next){
    //config 注入中间件，方便调用配置信息
    if(!this.config){
        this.config = config;
    }
    yield next;
});
</code></pre><p>路由中获取配置：</p>
<pre><code>app.get(&apos;/config&apos;,function *(){
    var config = this.config;
    this.body = config.env;
});
</code></pre><p>页面输出是 local ，说明生产环境中 env 配置项已经被 local.js 中的配置所覆盖。</p>
<h1 id="debug模块的使用"><a href="#debug模块的使用" class="headerlink" title="debug模块的使用"></a>debug模块的使用</h1><p>推荐使用 debug 模块，debug 模块可以对log进行分组，而且只有设置了环境变量<code>DEBUG</code>的情况下才会输出 log 。</p>
<pre><code>var debug = require(&apos;debug&apos;)(&apos;book&apos;);
app.get(&apos;/config&apos;,function *(){
    var config = this.config;
    debug(&apos;env: %s&apos;,config.env);
    this.body = config.env;
});
</code></pre><p>配置环境变量：<code>DEBUG=book</code> ，这样只会输出 book 分组的 log 信息。</p>
<pre><code>DEBUG=book NODE_ENV=local node --harmony app.js
</code></pre><p>多个环境变量，使用空格隔开。</p>
<p>访问页面后，输出的log是：</p>
<p>book env: local +0ms</p>
<p><strong>如果去掉环境变量 DEBUG=book 将不输出任何信息，这样当我们需要调试某个模块文件时，可以保证只有该模块的 log ，不会被其他模块所干扰。</strong></p>
<p>如果我们想输出所有的调试信息呢？</p>
<p>可以使用 <code>DEBUG=*</code> 。</p>
<h1 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h1><p>日志是应用不可缺少的部分，但 koa 没有日志记录中间件，我们使用 <code>mini-logger</code> 。</p>
<p>mini-logger 会创建日志记录文件，自动使用日期归档，而且还可以自定义日志分类。</p>
<pre><code>var Logger = require(&apos;mini-logger&apos;);
var logger = Logger({
    dir: config.logDir,
    categories: [ &apos;router&apos;,&apos;model&apos;,&apos;controller&apos;],
    format: &apos;YYYY-MM-DD-[{category}][.log]&apos;
});
</code></pre><p><strong>dir</strong> ：指定日志放在哪里</p>
<p><strong>categorie</strong>s ：自定义日志分类</p>
<p><strong>format</strong> ：日志文件名格式</p>
<p>记录 Error() 实例：</p>
<pre><code>logger.error(new Error(&apos;test&apos;));
</code></pre><p><strong>使用 error() ，会将出错堆栈信息输出到 xxxx-xx-xx-error.log 文件中。</strong></p>
<p><strong>当定义自定义分类后，会自动注册分类日志方法</strong>，比如定义了 <code>categories: [&#39;router&#39;]</code>：</p>
<pre><code>logger.router(&apos;test router&apos;);
</code></pre><p><strong>就有了 logger.router() 方法，并将日志记录到 xxxx-xx-xx-router.log 文件中。</strong></p>
<hr>
<h1 id="ES6的generator"><a href="#ES6的generator" class="headerlink" title="ES6的generator"></a>ES6的generator</h1><p>ES6的generator 是 koa 的基础，想要用好 koa 离不开对 generator 的理解。</p>
<p>定义一个 generator 函数：</p>
<pre><code>var generator_func = function* () { };
</code></pre><p>接下来我们要用到 <code>yield</code> 关键字，<strong>用于停止执行和保存当前的堆栈</strong>。</p>
<p>我们通过一个数字的例子来演示其用法：</p>
<pre><code>var r = 3;

function* infinite_ap(a) {
    for( var i = 0; i &lt; 3 ; i++) {
        a = a + r ;
        yield a;
    }
}

var sum = infinite_ap(5);

console.log(sum.next()); // returns { value : 8, done : false }
console.log(sum.next()); // returns { value : 11, done: false }
console.log(sum.next()); // returns { value : 14, done: false }
console.log(sum.next()); //return { value: undefined, done: true }
</code></pre><p><strong>yield a 会暂停执行并保存当前堆栈，返回当前的a。</strong></p>
<p>generator 函数与普通函数不同，只定义遍历器，而不会执行，每次调用这个遍历器的<strong>next</strong>方法，就从函数体的头部或者上一次停下来的地方开始执行，直到遇到下一个yield语句为止。</p>
<p><strong>yield语句就是暂停标志，next方法遇到yield，就会暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回对象的value属性的值。</strong>当下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。如果没有再遇到新的yield语句，就一直运行到函数结束，将return语句后面的表达式的值，作为value属性的值，如果该函数没有return语句，则value属性的值为undefined。</p>
<p>当第一次调用 sum.next() 时 返回的a变量值是5 + 3，同理第二次调用 sum.next() ，a变量值是8 +3，知道循环执行结束，返回done:true标识。</p>
<p>大家有没有发现个问题，koa 中 generator 的用法与上述 demo 演示的用法有非常大得差异，那是因为<strong>koa 中的 generator 使用了 co 进行了封装</strong>。</p>
<hr>
<h1 id="co-的简单使用"><a href="#co-的简单使用" class="headerlink" title="co 的简单使用"></a>co 的简单使用</h1><pre><code>var co = require(&apos;co&apos;);
var fs = require(&apos;fs&apos;);

function read(file) {
  return function(fn){
    fs.readFile(file, &apos;utf8&apos;, fn);
  }
}
co(function *(){

  var a = yield read(&apos;.gitignore&apos;);
  console.log(a.length);

  var b = yield read(&apos;package.json&apos;);
  console.log(b.length);
});
</code></pre><p>co 要求所有的异步函数必须是偏函数，称之为 thunk :</p>
<pre><code>function read(file) {
  return function(fn){
    fs.readFile(file, &apos;utf8&apos;, fn);
  }
}
</code></pre><p>上述代码封装了 fs.readFile() 异步读取文件的方法。</p>
<p>node 异步方法的回调函数规范是 function(err,result){} ,co 会处理该形式的函数，result或error会在异步函数执行完毕后获取到。</p>
<p>如果需要对 thunk 的返回数据做下处理，可以这么写：</p>
<pre><code>function read(file) {
  return function(fn){
    fs.readFile(file, &apos;utf8&apos;, function(err,result){
        if (err) return fn(err);
        fn(null, result);
    });
  }
}
</code></pre><p>如果嫌写thunk函数别扭，可以使用 thunkify：</p>
<pre><code>var thunkify = require(&apos;thunkify&apos;);
var fs = require(&apos;fs&apos;);

var read = thunkify(fs.readFile);
</code></pre><p>获取 thunk 函数的结果，只要使用 yield 关键字：</p>
<pre><code>var a = yield read(&apos;.gitignore&apos;);
console.log(a.length);
</code></pre><p><strong>在 co 中，我们无需使用控制流程的 next 方法，co 已经封装了 generator function 的流转。</strong></p>
<hr>
<blockquote>
<p>中间件从上到下执行完后，可以从下到上执行 yield next 后的逻辑</p>
</blockquote>
<pre><code>var app = new SimpleKoa();

app.use(function *(next){
    this.body = &apos;1&apos;;
    yield next;
    this.body += &apos;5&apos;;
    console.log(this.body);
});
app.use(function *(next){
    this.body += &apos;2&apos;;
    yield next;
    this.body += &apos;4&apos;;
});
app.use(function *(next){
    this.body += &apos;3&apos;;
});
app.listen();
</code></pre><p><strong>执行后控制台输出：123456</strong></p>
<hr>
<h1 id="ES6的Promise"><a href="#ES6的Promise" class="headerlink" title="ES6的Promise"></a>ES6的Promise</h1><pre><code>var promise = new Promise(function(resolve, reject){
    FS.readFile(&quot;foo.txt&quot;, &quot;utf-8&quot;, function (error, text) {
        if (error) {
            reject(new Error(error));
        } else {
            resolve(text);
        }
    });
}
return promise;
</code></pre><p>使用 promise：</p>
<pre><code>promise.then(function(){

}).fail(function(){

})
</code></pre><hr>
<h1 id="node单元测试"><a href="#node单元测试" class="headerlink" title="node单元测试"></a>node单元测试</h1><p><strong>mocha</strong> 是最好的 node 单元测试框架，使用简单且灵活，是进行 node 单测的首选。</p>
<pre><code>webstorm 已经集成 mocha 。
</code></pre><p>安装 mocha：</p>
<pre><code>npm install -g mocha    
</code></pre><p>案例：</p>
<pre><code>var assert = require(&quot;assert&quot;);
describe(&apos;Array&apos;, function() {
    describe(&apos;#indexOf()&apos;, function() {
        it(&apos;should return -1 when the value is not present&apos;, function() {
            assert.equal(-1, [1,2,3].indexOf(5));
            assert.equal(-1, [1,2,3].indexOf(0));
        });
    });
});
</code></pre><ul>
<li><p>assert 模块是 node 内置的断言库。</p>
</li>
<li><p>describe() 用于定义测试用例组，是可以嵌套的。</p>
</li>
<li><p>it() 是定义具体的测试用例。</p>
</li>
<li><p>assert.equal() 用于判断值是否符合预期。</p>
</li>
</ul>
<p>命令行运行用例 ：</p>
<pre><code>mocha
</code></pre><p>输出结果：</p>
<pre><code>Array
#indexOf()
  ✓ should return -1 when the value is not present
</code></pre><hr>
<h1 id="should断言库"><a href="#should断言库" class="headerlink" title="should断言库"></a>should断言库</h1><p>node 内置的断言库 assert ，功能比较弱，不太好用，推荐使用 <code>should</code> 。</p>
<p>should 的断言方法注入到 Object.prototype 中，所以断言的风格更符合用户思维习惯，也支持链式调用，跟 jQuery 有点像：</p>
<pre><code>var should = require(&quot;should&quot;);
describe(&apos;Should test&apos;, function() {
    it(&apos;number&apos;, function() {
        (123).should.be.a.Number;
    });
    it(&apos;object property&apos;, function() {
        var obj = {name:&apos;minghe&apos;,email:&quot;minghe36@gmail.com&quot;};
        obj.should.have.property(&apos;name&apos;,&apos;minghe&apos;);
        obj.should.have.property(&apos;email&apos;);
    });
});
</code></pre><blockquote>
<p>(123).should.be.a.Number 判断 123 是否是一个数字，适用于其他类型的判断。</p>
<p>obj.should.have.property(‘name’,’minghe’) obj 对象是否包含属性 name ，且 name = ‘minghe’ 。</p>
</blockquote>
<h2 id="常用的-api"><a href="#常用的-api" class="headerlink" title="常用的 api"></a>常用的 api</h2><p>使用 ok 判断值是否为 true：</p>
<pre><code>it(&apos;ok&apos;,function(){
    (true).should.be.ok;
})
</code></pre><p>使用 equal 判断一个值是否符合预期：</p>
<pre><code>it(&apos;equal&apos;,function(){
    &apos;abc&apos;.should.equal(&apos;abc&apos;);
});
</code></pre><p>使用 not 取反：</p>
<pre><code>it(&apos;not equal&apos;,function(){
    &apos;abc&apos;.should.not.equal(&apos;ddd&apos;);
});
</code></pre><p>判断值是否存在：</p>
<pre><code>it(&apos;exist&apos;,function(){
    var result = {};
    should.exist(result);
})
</code></pre><hr>
<h1 id="mocha异步测试"><a href="#mocha异步测试" class="headerlink" title="mocha异步测试"></a>mocha异步测试</h1><pre><code>var fs = require(&apos;fs&apos;);
var should = require(&apos;should&apos;);
describe(&apos;fs&apos;, function() {
    describe(&apos;#readFile()&apos;, function() {
        it(&apos;should not be null&apos;, function(done) {
            fs.readFile(&apos;./package.json&apos;, &apos;utf8&apos;, function(err,res){
                if (err) throw err;
                res.should.not.equal(null);
                done();
            });
        });
    });
});
</code></pre><p><strong>关键在于 done 实参，必须在执行完异步后（在异步回调中）执行下 done()，就能捕获到用例。<br>回调函数 done() 支持接收一个错误：done(err)，用于简化错误处理。</strong></p>
<hr>
<h1 id="supertest请求测试"><a href="#supertest请求测试" class="headerlink" title="supertest请求测试"></a>supertest请求测试</h1><p>在 node 业务应用中，我们经常需要<code>测试路由</code>的可用性，如何处理呢？</p>
<p>可以使用<code>supertest</code> 模块，supertest 专门<code>用于 http 断言，支持 koa 的 http 请求测试</code>。</p>
<p><strong>为了保证应用的可测试性，我们需要把应用脚本比如 app.js 中的 koa 实例暴露出来：</strong></p>
<pre><code>var koa = require(&apos;koa&apos;);
var app = koa();
//一堆中间件...
module.exports = app;
</code></pre><p>用例写法：</p>
<pre><code>var superagent = require(&apos;supertest&apos;);
var app = require(&apos;../app&apos;);

function request() {
    return superagent(app.listen());
}

describe(&apos;Routes&apos;, function () {
    describe(&apos;GET /&apos;, function () {
        it(&apos;should return 200&apos;, function (done) {
            request()
                .get(&apos;/&apos;)
                .expect(200, done);
        });
    });
});
</code></pre><p><code>superagent(app.listen())</code> 会截获 koa 的 http 请求，可以使用 get 、 post 等方法，对请求进行测试。</p>
<pre><code>request()
    .get(&apos;/&apos;)
    .expect(200, done);
</code></pre><p><strong>get(‘/‘) 即测试首页 get 请求，.expect(200, done) 测试 请求状态码是否为 200 （请求成功），done 是必须传入的，这样请求测试结束后，才能把测试信息推送给mocha处理。</strong></p>
<p>上述测试代码等价于：</p>
<pre><code>request()
    .get(&apos;/&apos;)
    .expect(200)
    .end(function(err, res){
        if (err) return done(err);
        done();
    });
</code></pre><p>.end() 回调会在请求完成后触发，可以在回调中对错误进行处理，res 包含完整的请求信息，可以对这些信息进行测试，比如页面输出的内容等。</p>
<p>运行命令 ：</p>
<pre><code>mocha --harmony
</code></pre><p><strong>留意：测试 koa 的请求必须加–harmony，否者会抛异常。</strong></p>
<p>我们经常需要对 <strong>json 接口的数据结构合法性进行测试</strong>，如何借助 supertest 实现测试呢？</p>
<p>我们新建个 /api/user/:id 的路由，返回一个用户信息：</p>
<pre><code>app.get(&apos;/api/user/:id&apos;,function *(){
    var user = {name:&apos;minghe&apos;,email:&apos;minghe36@gmail.com&apos;};
    user = JSON.stringify(user);
    this.body = user;
})
</code></pre><p>测试此路由是否返回正确的数据：</p>
<pre><code>it(&apos;should be json&apos;,function(done){
    request()
        .get(&apos;/api/user/1&apos;)
        .expect(200)
        .end(function(err, res){
            if (err) return done(err);
            var text = res.text;
            var json = JSON.parse(text);
            json.should.have.property(&apos;email&apos;);
            json.should.have.property(&apos;minghe&apos;);
            done();
        });
})
</code></pre><p>supertest 很强大，<strong>可以设置请求的头信息</strong>，使用 set() ：</p>
<pre><code>request()
    .get(&apos;/&apos;)
    .set(&apos;Accept&apos;, &apos;application/json&apos;)
    .expect(&apos;Content-Type&apos;, /json/)    
</code></pre><p><strong>而 expect() 除了支持状态码测试外，还支持头信息测试：.expect(‘Content-Type’, /json/)</strong></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/06/21/xtemplate模板引擎/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          xtemplate模板引擎
        
      </div>
    </a>
  
  
    <a href="/2016/06/20/Hexo使用笔记/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Hexo使用笔记</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Koa学习笔记" data-title="Koa学习笔记" data-url="http://yoursite.com/2016/06/21/Koa学习笔记/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"etc1208"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Yang He
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>





  </div>
</body>
</html>